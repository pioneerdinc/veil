package crypto

import (
	"encoding/hex"
	"strings"
	"testing"
)

func TestNewEngine(t *testing.T) {
	tests := []struct {
		name    string
		keyHex  string
		wantErr bool
		errMsg  string
	}{
		{
			name:    "valid 32-byte hex key",
			keyHex:  "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
			wantErr: false,
		},
		{
			name:    "valid key generated by GenerateRandomKey",
			keyHex:  func() string { k, _ := GenerateRandomKey(); return k }(),
			wantErr: false,
		},
		{
			name:    "invalid hex string",
			keyHex:  "not-a-hex-string",
			wantErr: true,
			errMsg:  "invalid master key format",
		},
		{
			name:    "wrong key length - too short",
			keyHex:  "0123456789abcdef",
			wantErr: true,
			errMsg:  "invalid key length",
		},
		{
			name:    "wrong key length - 31 bytes (odd hex)",
			keyHex:  "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcde",
			wantErr: true,
			errMsg:  "invalid master key format",
		},
		{
			name:    "wrong key length - 33 bytes",
			keyHex:  "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef00",
			wantErr: true,
			errMsg:  "invalid key length",
		},
		{
			name:    "empty key",
			keyHex:  "",
			wantErr: true,
			errMsg:  "invalid key length",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			engine, err := NewEngine(tt.keyHex)
			if tt.wantErr {
				if err == nil {
					t.Errorf("NewEngine() expected error but got nil")
					return
				}
				if !strings.Contains(err.Error(), tt.errMsg) {
					t.Errorf("NewEngine() error = %v, want error containing %v", err, tt.errMsg)
				}
			} else {
				if err != nil {
					t.Errorf("NewEngine() unexpected error = %v", err)
					return
				}
				if engine == nil {
					t.Errorf("NewEngine() returned nil engine")
				}
				if len(engine.key) != 32 {
					t.Errorf("NewEngine() key length = %d, want 32", len(engine.key))
				}
			}
		})
	}
}

func TestEngine_EncryptDecrypt(t *testing.T) {
	keyHex := "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"
	engine, err := NewEngine(keyHex)
	if err != nil {
		t.Fatalf("Failed to create engine: %v", err)
	}

	tests := []struct {
		name  string
		value string
	}{
		{
			name:  "simple string",
			value: "hello world",
		},
		{
			name:  "empty string",
			value: "",
		},
		{
			name:  "long string",
			value: "This is a very long string with many characters and special symbols !@#$%^&*()_+{}|:<>?",
		},
		{
			name:  "unicode string",
			value: "Hello ‰∏ñÁïå üåç √©mojis and √ºn√Øc√∂d√© characters",
		},
		{
			name:  "binary-like data as string",
			value: string([]byte{0x00, 0x01, 0x02, 0x03, 0xff, 0xfe}),
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Encrypt
			encrypted, err := engine.Encrypt(tt.value)
			if err != nil {
				t.Errorf("Encrypt() error = %v", err)
				return
			}

			// Verify encrypted value is hex
			if _, err := hex.DecodeString(encrypted); err != nil {
				t.Errorf("Encrypt() returned non-hex string: %v", err)
			}

			// Encrypted value should be different from plaintext
			if encrypted == tt.value && tt.value != "" {
				t.Errorf("Encrypt() returned same value as input")
			}

			// Decrypt
			decrypted, err := engine.Decrypt(encrypted)
			if err != nil {
				t.Errorf("Decrypt() error = %v", err)
				return
			}

			// Verify decrypted value matches original
			if decrypted != tt.value {
				t.Errorf("Decrypt() = %v, want %v", decrypted, tt.value)
			}
		})
	}
}

func TestEngine_EncryptDifferentResults(t *testing.T) {
	keyHex := "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"
	engine, err := NewEngine(keyHex)
	if err != nil {
		t.Fatalf("Failed to create engine: %v", err)
	}

	value := "test value"

	// Encrypt the same value twice
	encrypted1, err := engine.Encrypt(value)
	if err != nil {
		t.Fatalf("First Encrypt() error = %v", err)
	}

	encrypted2, err := engine.Encrypt(value)
	if err != nil {
		t.Fatalf("Second Encrypt() error = %v", err)
	}

	// Due to random nonce, encrypted values should be different
	if encrypted1 == encrypted2 {
		t.Errorf("Encrypt() produced identical output for same input - should use random nonce")
	}

	// But both should decrypt to the same value
	decrypted1, err := engine.Decrypt(encrypted1)
	if err != nil {
		t.Errorf("Decrypt() first error = %v", err)
	}

	decrypted2, err := engine.Decrypt(encrypted2)
	if err != nil {
		t.Errorf("Decrypt() second error = %v", err)
	}

	if decrypted1 != value || decrypted2 != value {
		t.Errorf("Decrypt() values don't match original")
	}
}

func TestEngine_DecryptInvalid(t *testing.T) {
	keyHex := "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"
	engine, err := NewEngine(keyHex)
	if err != nil {
		t.Fatalf("Failed to create engine: %v", err)
	}

	tests := []struct {
		name    string
		input   string
		wantErr bool
		errMsg  string
	}{
		{
			name:    "invalid hex",
			input:   "not-valid-hex!!!",
			wantErr: true,
			errMsg:  "error decoding hex",
		},
		{
			name:    "too short ciphertext",
			input:   "1234",
			wantErr: true,
			errMsg:  "ciphertext too short",
		},
		{
			name: "wrong key - valid hex but different key",
			input: func() string {
				// Create engine with different key and encrypt
				otherKey := "fedcba9876543210fedcba9876543210fedcba9876543210fedcba9876543210"
				otherEngine, _ := NewEngine(otherKey)
				enc, _ := otherEngine.Encrypt("test")
				return enc
			}(),
			wantErr: true,
			errMsg:  "error decrypting",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			_, err := engine.Decrypt(tt.input)
			if tt.wantErr {
				if err == nil {
					t.Errorf("Decrypt() expected error but got nil")
					return
				}
				if !strings.Contains(err.Error(), tt.errMsg) {
					t.Errorf("Decrypt() error = %v, want error containing %v", err, tt.errMsg)
				}
			} else {
				if err != nil {
					t.Errorf("Decrypt() unexpected error = %v", err)
				}
			}
		})
	}
}

func TestEngine_DifferentKeys(t *testing.T) {
	key1 := "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"
	key2 := "fedcba9876543210fedcba9876543210fedcba9876543210fedcba9876543210"

	engine1, err := NewEngine(key1)
	if err != nil {
		t.Fatalf("Failed to create engine1: %v", err)
	}

	engine2, err := NewEngine(key2)
	if err != nil {
		t.Fatalf("Failed to create engine2: %v", err)
	}

	value := "secret data"

	// Encrypt with first engine
	encrypted, err := engine1.Encrypt(value)
	if err != nil {
		t.Fatalf("Encrypt() error = %v", err)
	}

	// Try to decrypt with second engine - should fail
	_, err = engine2.Decrypt(encrypted)
	if err == nil {
		t.Errorf("Decrypt() with wrong key should have failed")
	}

	// Decrypt with first engine - should succeed
	decrypted, err := engine1.Decrypt(encrypted)
	if err != nil {
		t.Errorf("Decrypt() with correct key error = %v", err)
	}

	if decrypted != value {
		t.Errorf("Decrypt() = %v, want %v", decrypted, value)
	}
}
