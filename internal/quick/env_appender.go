package quick

import (
	"bufio"
	"bytes"
	"fmt"
	"os"
	"strings"
	"time"
)

// AppendToEnvFile appends a single key=value pair to an .env file
func AppendToEnvFile(path, key, value string, force bool) error {
	if key == "" {
		return fmt.Errorf("--name is required when using --to")
	}

	fileExists := false
	if _, err := os.Stat(path); err == nil {
		fileExists = true
	}

	if fileExists {
		existingValue, exists := findKeyInFile(path, key)
		if exists {
			if !force {
				return fmt.Errorf("%s already exists in %s, use --force to overwrite", key, path)
			}
			return updateKeyInFile(path, key, value, existingValue)
		}
	}

	return appendKeyToFile(path, key, value, fileExists)
}

// AppendBatchToEnvFile appends multiple secrets to an .env file
func AppendBatchToEnvFile(path string, results []*Result, force bool) error {
	fileExists := false
	if _, err := os.Stat(path); err == nil {
		fileExists = true
	}

	existingKeys := make(map[string]string)
	if fileExists {
		existingKeys = parseEnvFile(path)
	}

	for _, result := range results {
		if result.EnvName == "" {
			return fmt.Errorf("all batch secrets must have a name")
		}
		if _, exists := existingKeys[result.EnvName]; exists && !force {
			return fmt.Errorf("%s already exists in %s, use --force to overwrite", result.EnvName, path)
		}
	}

	var content strings.Builder

	// Read existing content if appending
	if fileExists {
		data, err := os.ReadFile(path)
		if err != nil {
			return fmt.Errorf("failed to read file: %w", err)
		}

		// If force, we need to update existing keys
		if force {
			lines := parseEnvFileWithLines(path)

			// Build a map of env name to value for efficient lookups
			updates := make(map[string]string, len(results))
			for _, result := range results {
				updates[result.EnvName] = result.Value
			}

			// Single pass over lines with O(1) lookups
			for i, line := range lines {
				if newVal, ok := updates[line.key]; ok {
					lines[i].value = newVal
					lines[i].original = fmt.Sprintf("%s=%s", line.key, escapeValue(newVal))
				}
			}
			for _, line := range lines {
				content.WriteString(line.original)
				content.WriteString("\n")
			}
		} else {
			content.Write(data)
			if !bytes.HasSuffix(data, []byte("\n")) {
				content.WriteString("\n")
			}
		}
	}

	newKeys := make([]*Result, 0)
	for _, result := range results {
		if _, exists := existingKeys[result.EnvName]; !exists {
			newKeys = append(newKeys, result)
		}
	}

	if len(newKeys) > 0 {
		content.WriteString(fmt.Sprintf("\n# Generated by veil on %s\n", time.Now().Format(time.RFC3339)))
		for _, result := range newKeys {
			content.WriteString(fmt.Sprintf("%s=%s\n", result.EnvName, escapeValue(result.Value)))
		}
	}

	return os.WriteFile(path, []byte(content.String()), 0600)
}

func findKeyInFile(path, key string) (string, bool) {
	keys := parseEnvFile(path)
	value, exists := keys[key]
	return value, exists
}

func parseEnvFile(path string) map[string]string {
	result := make(map[string]string)
	data, err := os.ReadFile(path)
	if err != nil {
		return result
	}

	scanner := bufio.NewScanner(bytes.NewReader(data))
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		if line == "" || strings.HasPrefix(line, "#") {
			continue
		}

		if k, v, found := strings.Cut(line, "="); found {
			result[k] = unescapeValue(v)
		}
	}

	return result
}

type envLine struct {
	key      string
	value    string
	original string
}

func parseEnvFileWithLines(path string) []envLine {
	var lines []envLine
	data, err := os.ReadFile(path)
	if err != nil {
		return lines
	}

	scanner := bufio.NewScanner(bytes.NewReader(data))
	for scanner.Scan() {
		text := scanner.Text()
		line := envLine{original: text}

		trimmed := strings.TrimSpace(text)
		if trimmed != "" && !strings.HasPrefix(trimmed, "#") {
			if k, v, found := strings.Cut(trimmed, "="); found {
				line.key = strings.TrimSpace(k)
				line.value = unescapeValue(v)
			}
		}

		lines = append(lines, line)
	}

	return lines
}

func updateKeyInFile(path, key, newValue, _ string) error {
	lines := parseEnvFileWithLines(path)

	for i, line := range lines {
		if line.key == key {
			lines[i].value = newValue
			lines[i].original = fmt.Sprintf("%s=%s", key, escapeValue(newValue))
			break
		}
	}

	var content strings.Builder
	for _, line := range lines {
		content.WriteString(line.original)
		content.WriteString("\n")
	}

	return os.WriteFile(path, []byte(content.String()), 0600)
}

func appendKeyToFile(path, key, value string, fileExists bool) error {
	var content strings.Builder

	if fileExists {
		data, err := os.ReadFile(path)
		if err != nil {
			return fmt.Errorf("failed to read file: %w", err)
		}
		content.Write(data)
		if !bytes.HasSuffix(data, []byte("\n")) {
			content.WriteString("\n")
		}
	}

	// Add timestamp comment
	content.WriteString(fmt.Sprintf("# Generated by veil on %s\n", time.Now().Format(time.RFC3339)))
	content.WriteString(fmt.Sprintf("%s=%s\n", key, escapeValue(value)))

	return os.WriteFile(path, []byte(content.String()), 0600)
}

func escapeValue(value string) string {
	if strings.ContainsAny(value, " \t#\"'") {
		return fmt.Sprintf("\"%s\"", strings.ReplaceAll(value, "\"", "\\\""))
	}
	return value
}

func unescapeValue(value string) string {
	value = strings.TrimSpace(value)
	if strings.HasPrefix(value, "\"") && strings.HasSuffix(value, "\"") {
		value = value[1 : len(value)-1]
		value = strings.ReplaceAll(value, "\\\"", "\"")
	}
	return value
}
